#!/usr/bin/python
# CC-BY: hasherezade
"""Decoder for 7even-HONE$T ransomware"""

import argparse
import os

PREFIX = 'M'
SUFFIX = '**'

#for old version of 7ev3n:
FNAME_KEY_R5A_OLD = "SHdbvntkorcfrertgejviotrgj689534hf4tuionc4IHDSbngjvkmrregtrhgfevtbtvnviotnrcejk4vnm30ij4t4"

#for 7ev3n HONE$T:
FNAME_KEY_R4A = 'ANOASudgfjfirtj4k504iojm5io5nm59uh5vob5mho5p6gf2u43i5hojg4mf4i05j6g594cn9mjg6h'
FNAME_KEY_R5A = 'ASIBVbhciJ5hv6bjyuwetjykok7mbvtbvtiJ5h6jg54ifj0655iJ5hok7mbok7mbvtvtv6bjfib56j45fkmbvtiJ5hv6bokok7mb'

def decode(data, key, offset=0):
    maxlen = len(data)
    keylen = len(key)
    j = 0 #key index
    decoded = bytearray()
    for i in range(offset, maxlen):
        dec = data[i] ^ key[j % keylen]
        j += 1
        decoded.append(dec) 
    return decoded

def search_suffix(filep):
    filep.seek(0, os.SEEK_END)
    size = filep.tell()

    pos = size - 1
    filep.seek(pos, os.SEEK_SET)
    data = filep.read(1)
    if data != '\x0a':
        return None
    pos -= 1
    buffer = ""
    prev_data = None
    while pos > 0:
        filep.seek(pos, os.SEEK_SET)
        data = filep.read(1)
        pos -= 1
        if data == '*' and prev_data == '*':
            break
        if data == '*':
            prev_data = '*'
            continue
        else:
            if prev_data == '*':
                buffer = prev_data + buffer
            prev_data = None
            buffer = data + buffer
    return buffer

def read_encrypted(filep, suffix_len):
    filep.seek(0, os.SEEK_END)
    size = filep.tell()
    if size < suffix_len:
        return None
    filep.seek(0, os.SEEK_SET)
    data = filep.read(1)
    if data != PREFIX:
        print "encrypted not found"
        return None
    return filep.read(size - suffix_len)

def main():
    parser = argparse.ArgumentParser(description="Data XOR")
    parser.add_argument('--file', dest="file", default=None, help="Input file", required=True)
    parser.add_argument('--old', dest="old", default=False, help="Is it old version of 7ev3n?", action='store_true')
    args = parser.parse_args()
    
    fp = open(args.file, 'rb')
    fname = search_suffix(fp)
    if fname == None or len(fname) == 0:
        print "Failed to recover file name"
        exit (-1)

    is_r4a = False
    if args.file.endswith("R5A"):
        if args.old == True:
            fname_key = FNAME_KEY_R5A_OLD
        else:
            fname_key = FNAME_KEY_R5A
        print "R5A"
    else:
        fname_key = FNAME_KEY_R4A
        is_r4a = True
        print "R4A"

    orig_fname = decode(bytearray(fname), bytearray(fname_key))
    print "[+] Original name: " + orig_fname
    suffix_len = len(orig_fname) + len('**') + len('\x0a') + 1
    
    dirname = os.path.dirname(args.file)
    orig_fname = os.path.join(dirname, orig_fname)
    
    if is_r4a:
        data = read_encrypted(fp, suffix_len)
        outdata = decode(bytearray(data), bytearray(fname_key))
        outfile = open(str(orig_fname), 'wb')
        if outfile is None:
            print "Error creating file: " + orig_fname
            return (-2)
        outfile.write(outdata)
        outfile.close()
        print "[+] Decoded to: " + orig_fname
        return 0
    else:
        print "[-] R5A not supported yet"
        return (-2)

if __name__ == "__main__":
    main()

